"""
Professional pytest configuration with proper Flask-SQLAlchemy integration
"""
import pytest
import os
import sys
from flask import Flask
from sqlalchemy.orm import scoped_session, sessionmaker
from datetime import datetime, timedelta

# Import app factory
from src.app import create_app
from src.database import db as _db
from src.models.user import User
from src.models.user import EmailVerificationToken

# Import test configs
from test_config import SQLiteTestConfig, PostgreSQLTestConfig


# ============================================================================
# PYTEST CONFIGURATION
# ============================================================================

def pytest_addoption(parser):
    """Add custom command line options"""
    parser.addoption(
        "--use-postgres",
        action="store_true",
        default=False,
        help="Use PostgreSQL test database instead of SQLite"
    )


# ============================================================================
# SESSION SCOPE FIXTURES (Created once per test session)
# ============================================================================

@pytest.fixture(scope='session')
def app(request):
    """Create Flask app for testing"""
    # Use PostgreSQL by default (models use JSONB which SQLite doesn't support)
    config = PostgreSQLTestConfig
    
    # Create app using factory
    app = Flask(__name__)
    app.config.from_object(config)
    
    # Initialize database
    from src.database import init_db
    init_db(app)
    
    # Establish application context
    ctx = app.app_context()
    ctx.push()
    
    yield app
    
    # Cleanup
    ctx.pop()


@pytest.fixture(scope='session')
def database(app):
    """Create database tables"""
    # Create all tables
    _db.create_all()
    
    yield _db
    
    # Drop all tables after tests
    _db.drop_all()


# ============================================================================
# FUNCTION SCOPE FIXTURES (Created for each test)
# ============================================================================

@pytest.fixture(scope='function')
def session(database):
    """
    Create a new database session for each test with proper isolation.
    Uses nested transactions to ensure complete rollback after each test.
    """
    # Start a connection
    connection = database.engine.connect()
    
    # Begin a non-ORM transaction
    transaction = connection.begin()
    
    # Create a session bound to the connection
    # Use scoped_session so Flask-SQLAlchemy's teardown can call .remove()
    session_factory = sessionmaker(bind=connection)
    Session = scoped_session(session_factory)
    
    # Override Flask-SQLAlchemy's session
    database.session = Session
    
    yield Session
    
    # Rollback everything - no data persists between tests
    Session.remove()
    transaction.rollback()
    connection.close()


@pytest.fixture(scope='function')
def client(app, session):
    """Create Flask test client"""
    with app.test_client() as client:
        yield client


# ============================================================================
# USER FIXTURES
# ============================================================================

@pytest.fixture
def test_user(session):
    """Create a test user"""
    user = User(
        email='test@example.com',
        first_name='Test',
        last_name='User',
        role='trader',
        is_active=True,
        is_verified=True
    )
    user.set_password('TestPassword123!')
    session.add(user)
    session.commit()
    return user


@pytest.fixture
def admin_user(session):
    """Create an admin user"""
    user = User(
        email='admin@example.com',
        first_name='Admin',
        last_name='User',
        role='super_admin',
        is_active=True,
        is_verified=True,
        can_create_same_role=True
    )
    user.set_password('AdminPassword123!')
    session.add(user)
    session.commit()
    return user


@pytest.fixture
def master_user(session):
    """Create a master user"""
    user = User(
        email='master@example.com',
        first_name='Master',
        last_name='User',
        role='master',
        is_active=True,
        is_verified=True
    )
    user.set_password('MasterPassword123!')
    session.add(user)
    session.commit()
    return user


@pytest.fixture
def affiliate_user(session, super_admin_user):
    """Create an affiliate user"""
    user = User(
        email='affiliate@example.com',
        first_name='Affiliate',
        last_name='User',
        role='affiliate',
        is_active=True,
        is_verified=True,
        parent_id=super_admin_user.id
    )
    user.set_password('AffiliatePassword123!')
    session.add(user)
    session.commit()
    session.refresh(user)  # Refresh to load parent relationship
    user.update_tree_path()
    session.commit()
    user.generate_referral_code()
    session.commit()
    return user


@pytest.fixture
def super_admin_user(session):
    """Create a super admin user (root)"""
    user = User(
        email='superadmin@example.com',
        first_name='Super',
        last_name='Admin',
        role='super_admin',
        is_active=True,
        is_verified=True,
        can_create_same_role=True,
        parent_id=None  # Root user
    )
    user.set_password('SuperAdminPassword123!')
    session.add(user)
    session.commit()
    user.update_tree_path()
    session.commit()
    return user


@pytest.fixture
def trader_user(session, super_admin_user):
    """Create a trader user"""
    user = User(
        email='trader@example.com',
        first_name='Trader',
        last_name='User',
        role='trader',
        is_active=True,
        is_verified=True,
        parent_id=super_admin_user.id
    )
    user.set_password('TraderPassword123!')
    session.add(user)
    session.commit()
    user.update_tree_path()
    session.commit()
    return user


# ============================================================================
# AUTH FIXTURES
# ============================================================================

@pytest.fixture
def auth_headers(test_user):
    """Get authentication headers for test user"""
    token = test_user.generate_access_token()
    return {'Authorization': f'Bearer {token}'}


@pytest.fixture
def admin_auth_headers(admin_user):
    """Get authentication headers for admin user"""
    token = admin_user.generate_access_token()
    return {'Authorization': f'Bearer {token}'}


# ============================================================================
# MOCK FIXTURES
# ============================================================================

@pytest.fixture
def mock_sendgrid(mocker):
    """Mock SendGrid email service"""
    return mocker.patch('src.services.email_service.send_email')


@pytest.fixture
def mock_nowpayments(mocker):
    """Mock NowPayments API"""
    return mocker.patch('src.services.nowpayments_service.create_payment')


@pytest.fixture
def mock_discord(mocker):
    """Mock Discord webhook"""
    return mocker.patch('src.services.discord_service.send_notification')


# ============================================================================
# TIME FIXTURES
# ============================================================================

@pytest.fixture
def freeze_time(mocker):
    """Freeze time for testing time-sensitive features"""
    frozen_time = datetime(2025, 1, 1, 12, 0, 0)
    mocker.patch('datetime.datetime').utcnow.return_value = frozen_time
    return frozen_time


@pytest.fixture
def unverified_user(session, super_admin_user):
    """Create an unverified user"""
    user = User(
        email='unverified@example.com',
        first_name='Unverified',
        last_name='User',
        role='trader',
        is_active=True,
        is_verified=False,
        parent_id=super_admin_user.id
    )
    user.set_password('UnverifiedPassword123!')
    session.add(user)
    session.commit()
    session.refresh(user)
    user.update_tree_path()
    session.commit()
    return user

@pytest.fixture
def agent_user(session, super_admin_user):
    """Create an agent user with agent profile"""
    from src.models import Agent
    
    user = User(
        email='agent@example.com',
        first_name='Agent',
        last_name='User',
        role='affiliate',
        is_active=True,
        is_verified=True,
        parent_id=super_admin_user.id
    )
    user.set_password('AgentPassword123!')
    session.add(user)
    session.commit()
    session.refresh(user)
    user.update_tree_path()
    session.commit()
    
    # Create agent profile
    agent = Agent(
        user_id=user.id,
        agent_code='AGENT001',
        commission_rate=10.0,
        is_active=True
    )
    session.add(agent)
    session.commit()
    
    return user

@pytest.fixture
def referral_user(session, agent_user, super_admin_user):
    """Create a referred user"""
    from src.models import Agent, Referral
    
    user = User(
        email='referred@example.com',
        first_name='Referred',
        last_name='User',
        role='trader',
        is_active=True,
        is_verified=True,
        parent_id=super_admin_user.id
    )
    user.set_password('ReferredPassword123!')
    session.add(user)
    session.commit()
    session.refresh(user)
    user.update_tree_path()
    session.commit()
    
    # Create referral record
    agent = Agent.query.filter_by(user_id=agent_user.id).first()
    referral = Referral(
        agent_id=agent.id,
        referred_user_id=user.id,
        referral_code='AGENT001',
        status='active'
    )
    session.add(referral)
    session.commit()
    
    return user

@pytest.fixture
def tenant(session):
    """Create a tenant"""
    from src.models import Tenant
    
    tenant = Tenant(
        name='Test Tenant',
        subdomain='test',
        status="active"
    )
    session.add(tenant)
    session.commit()
    
    return tenant

@pytest.fixture
def trading_program(session, tenant):
    """Create a trading program"""
    from src.models import TradingProgram
    
    program = TradingProgram(
        tenant_id=tenant.id,
        name='Standard Challenge',
        type='one_phase',
        description='Standard trading challenge',
        account_size=10000.0,
        profit_target=10.0,  # 10%
        max_daily_loss=5.0,  # 5%
        max_total_loss=10.0,  # 10%
        price=100.0,
        profit_split=80.0,
        is_active=True
    )
    session.add(program)
    session.commit()
    
    return program

@pytest.fixture
def challenge(session, trader_user, trading_program):
    """Create a challenge"""
    from src.models import Challenge
    
    challenge = Challenge(
        user_id=trader_user.id,
        program_id=trading_program.id,
        status='active',
        initial_balance=10000.0,
        current_balance=10000.0
    )
    session.add(challenge)
    session.commit()
    
    return challenge
